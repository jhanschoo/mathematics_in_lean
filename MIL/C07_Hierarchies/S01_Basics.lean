import MIL.Common
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Data.Real.Basic

set_option autoImplicit true


class One‚ÇÅ (Œ± : Type) where
  /-- The element one -/
  one : Œ±


-- instance synthesis: when declared with the class keyword, we are able to talk about One‚ÇÅ generically as though it has an instance synthesized for it,
#check One‚ÇÅ.one -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±

@[class] structure One‚ÇÇ (Œ± : Type) where
  /-- The element one -/
  one : Œ±

-- Observe the different signature: we need to explicitly pass the instance as an argument here
#check One‚ÇÇ.one

-- Look at mathlib's One.one : ‚Ñï, which already has an instance defined for it
#check (One.one : ‚Ñï)

-- We cannot currently do the same for One‚ÇÅ.one
-- #check (One‚ÇÅ.one : ‚Ñï)

-- These examples are bogus, because we cannot synthesize an instance for One‚ÇÅ ‚Ñï (yet)
example (Œ± : Type) [One‚ÇÅ Œ±] : Œ± := One‚ÇÅ.one

example (Œ± : Type) [One‚ÇÅ Œ±] := (One‚ÇÅ.one : Œ±)

-- Annotation specifies that documentation for One‚ÇÅ.one should be shown in uses of the symbol ùüô
@[inherit_doc]
notation "ùüô" => One‚ÇÅ.one -- Defining the notation itself

example {Œ± : Type} [One‚ÇÅ Œ±] : Œ± := ùüô

example {Œ± : Type} [One‚ÇÅ Œ±] : (ùüô : Œ±) = ùüô := rfl


class Dia‚ÇÅ (Œ± : Type) where
  dia : Œ± ‚Üí Œ± ‚Üí Œ±

-- Defining the notation itself, alongside l/r-associativity and precedence
infixl:70 " ‚ãÑ "   => Dia‚ÇÅ.dia

-- Manually specifying that Semigroup‚ÇÅ is a specialization of Dia‚ÇÅ (at this point, toDia‚ÇÅ has no special treatment)
class Semigroup‚ÇÅ (Œ± : Type) where
  toDia‚ÇÅ : Dia‚ÇÅ Œ±
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)

-- We now tell Lean that toDia‚ÇÅ can be used when we use a Semigroup‚ÇÅ where a Dia‚ÇÅ is expected
attribute [instance] Semigroup‚ÇÅ.toDia‚ÇÅ

example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b

-- Better syntax for the above
class Semigroup‚ÇÇ (Œ± : Type) extends Dia‚ÇÅ Œ± where
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)

example {Œ± : Type} [Semigroup‚ÇÇ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b

class DiaOneClass‚ÇÅ (Œ± : Type) extends One‚ÇÅ Œ±, Dia‚ÇÅ Œ± where
  /-- One is a left neutral element for diamond. -/
  one_dia : ‚àÄ a : Œ±, ùüô ‚ãÑ a = a
  /-- One is a right neutral element for diamond -/
  dia_one : ‚àÄ a : Œ±, a ‚ãÑ ùüô = a



set_option trace.Meta.synthInstance true in
example {Œ± : Type} [DiaOneClass‚ÇÅ Œ±] (a b : Œ±) : Prop := a ‚ãÑ b = ùüô


class Monoid‚ÇÅ (Œ± : Type) extends Semigroup‚ÇÅ Œ±, DiaOneClass‚ÇÅ Œ±

-- note that this gives two distinct instances for Dia‚ÇÅ Œ±, one from Semigroup‚ÇÅ and one from DiaOneClass‚ÇÅ
class Monoid‚ÇÇ (Œ± : Type) where
  toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±
  toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±

-- the automatic version chooses one and aliases it to the other
example {Œ± : Type} [Monoid‚ÇÅ Œ±] :
  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia : Œ± ‚Üí Œ± ‚Üí Œ±) = Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia := rfl


/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/
#check Monoid‚ÇÇ.mk

-- We see that lean has torn the DiaOneClass‚ÇÅ instance apart and will separately synthesize the DiaOneClass‚ÇÅ instance
-- then, Monoid‚ÇÅ.toDiaOneClass‚ÇÅ is not a field, and we see that we have to have special handling in to_additive later
/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/
#check Monoid‚ÇÅ.mk


#check Monoid‚ÇÅ.toSemigroup‚ÇÅ
#check Monoid‚ÇÅ.toDiaOneClass‚ÇÅ


class Inv‚ÇÅ (Œ± : Type) where
  /-- The inversion function -/
  inv : Œ± ‚Üí Œ±

@[inherit_doc]
postfix:max "‚Åª¬π" => Inv‚ÇÅ.inv

class Group‚ÇÅ (G : Type) extends Monoid‚ÇÅ G, Inv‚ÇÅ G where
  inv_dia : ‚àÄ a : G, a‚Åª¬π ‚ãÑ a = ùüô


lemma left_inv_eq_right_inv‚ÇÅ {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê DiaOneClass‚ÇÅ.one_dia c, ‚Üê hba, Semigroup‚ÇÅ.dia_assoc, hac, DiaOneClass‚ÇÅ.dia_one b]

-- Export particular fields of classes to the top level
export DiaOneClass‚ÇÅ (one_dia dia_one)
export Semigroup‚ÇÅ (dia_assoc)
export Group‚ÇÅ (inv_dia)


example {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê one_dia c, ‚Üê hba, dia_assoc, hac, dia_one b]


lemma inv_eq_of_dia [Group‚ÇÅ G] {a b : G} (h : a ‚ãÑ b = ùüô) : a‚Åª¬π = b :=
  left_inv_eq_right_inv‚ÇÅ (inv_dia a) h

lemma dia_inv [Group‚ÇÅ G] (a : G) : a ‚ãÑ a‚Åª¬π = ùüô := by
  have h : (a ‚ãÑ a‚Åª¬π)‚Åª¬π ‚ãÑ (a ‚ãÑ a‚Åª¬π ‚ãÑ (a ‚ãÑ a‚Åª¬π)) = ùüô := by
    rw [dia_assoc, ‚Üê dia_assoc a‚Åª¬π a, inv_dia, one_dia, inv_dia]
  rw [‚Üê h, ‚Üê dia_assoc, inv_dia, one_dia]




class AddSemigroup‚ÇÉ (Œ± : Type) extends Add Œ± where
/-- Addition is associative -/
  add_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a + b + c = a + (b + c)

-- tells lean that AddSemigroup‚ÇÉ is the additive analog of Semigroup‚ÇÉ
@[to_additive AddSemigroup‚ÇÉ]
class Semigroup‚ÇÉ (Œ± : Type) extends Mul Œ± where
/-- Multiplication is associative -/
  mul_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a * b * c = a * (b * c)

class AddMonoid‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ±, AddZeroClass Œ±

-- tells lean that AddMonoid‚ÇÉ is the additive analog of Monoid‚ÇÉ
@[to_additive AddMonoid‚ÇÉ]
class Monoid‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ±, MulOneClass Œ±

-- as mentioned previously, toMulOneClass is not a field of Monoid‚ÇÉ and so requires special handling
attribute [to_additive existing] Monoid‚ÇÉ.toMulOneClass

export Semigroup‚ÇÉ (mul_assoc‚ÇÉ)
export AddSemigroup‚ÇÉ (add_assoc‚ÇÉ)

-- @[to_additive] tells lean that to generate the additive analog of the following lemma
whatsnew in
@[to_additive]
lemma left_inv_eq_right_inv' {M : Type} [Monoid‚ÇÉ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by
  rw [‚Üê one_mul c, ‚Üê hba, mul_assoc‚ÇÉ, hac, mul_one b]

#check left_neg_eq_right_neg'

class AddCommSemigroup‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ± where
  add_comm : ‚àÄ a b : Œ±, a + b = b + a

@[to_additive AddCommSemigroup‚ÇÉ]
class CommSemigroup‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ± where
  mul_comm : ‚àÄ a b : Œ±, a * b = b * a

class AddCommMonoid‚ÇÉ (Œ± : Type) extends AddMonoid‚ÇÉ Œ±, AddCommSemigroup‚ÇÉ Œ±

@[to_additive AddCommMonoid‚ÇÉ]
class CommMonoid‚ÇÉ (Œ± : Type) extends Monoid‚ÇÉ Œ±, CommSemigroup‚ÇÉ Œ±

class AddGroup‚ÇÉ (G : Type) extends AddMonoid‚ÇÉ G, Neg G where
  neg_add : ‚àÄ a : G, -a + a = 0

@[to_additive AddGroup‚ÇÉ]
class Group‚ÇÉ (G : Type) extends Monoid‚ÇÉ G, Inv G where
  inv_mul : ‚àÄ a : G, a‚Åª¬π * a = 1

-- registering the fields with the simplifier
attribute [simp] Group‚ÇÉ.inv_mul AddGroup‚ÇÉ.neg_add



@[to_additive]
lemma inv_eq_of_mul [Group‚ÇÉ G] {a b : G} (h : a * b = 1) : a‚Åª¬π = b := by
  rw [‚Üê mul_one a‚Åª¬π, ‚Üê h, ‚Üê mul_assoc‚ÇÉ, Group‚ÇÉ.inv_mul, one_mul]

-- registering the the additive analog's version of the lemma with the simplifier (this also registers the lemma itself with the simplifier)
@[to_additive (attr := simp)]
lemma Group‚ÇÉ.mul_inv {G : Type} [Group‚ÇÉ G] {a : G} : a * a‚Åª¬π = 1 := by
  have h : (a * a‚Åª¬π)‚Åª¬π * (a * a‚Åª¬π * (a * a‚Åª¬π)) = 1 := by
    rw [mul_assoc‚ÇÉ a a‚Åª¬π (a * a‚Åª¬π), ‚Üê mul_assoc‚ÇÉ a‚Åª¬π a, inv_mul, one_mul, inv_mul]
  rw [‚Üê h, ‚Üê mul_assoc‚ÇÉ, inv_mul, one_mul]

@[to_additive]
lemma mul_left_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : a * b = a * c) : b = c := by
  rw [‚Üê one_mul b, ‚Üê one_mul c, ‚Üê Group‚ÇÉ.inv_mul a, mul_assoc‚ÇÉ, mul_assoc‚ÇÉ, h]

@[to_additive]
lemma mul_right_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : b*a = c*a) : b = c := by
  rw [‚Üê mul_one b, ‚Üê mul_one c, ‚Üê Group‚ÇÉ.mul_inv, ‚Üê mul_assoc‚ÇÉ, h, mul_assoc‚ÇÉ]

class AddCommGroup‚ÇÉ (G : Type) extends AddGroup‚ÇÉ G, AddCommMonoid‚ÇÉ G

@[to_additive AddCommGroup‚ÇÉ]
class CommGroup‚ÇÉ (G : Type) extends Group‚ÇÉ G, CommMonoid‚ÇÉ G



class Ring‚ÇÉ (R : Type) extends AddGroup‚ÇÉ R, Monoid‚ÇÉ R, MulZeroClass R where
  /-- Multiplication is left distributive over addition -/
  left_distrib : ‚àÄ a b c : R, a * (b + c) = a * b + a * c
  /-- Multiplication is right distributive over addition -/
  right_distrib : ‚àÄ a b c : R, (a + b) * c = a * c + b * c

instance {R : Type} [Ring‚ÇÉ R] : AddCommGroup‚ÇÉ R :=
{ Ring‚ÇÉ.toAddGroup‚ÇÉ with
  add_comm := by
    intro a b
    have h‚ÇÅ : (1 + 1) * (a + b) = a + (a + b + b) := by
      rw [Ring‚ÇÉ.left_distrib]
      repeat rw [Ring‚ÇÉ.right_distrib]
      repeat rw [one_mul]
      repeat rw [‚Üê add_assoc‚ÇÉ]
    have h‚ÇÇ : (1 + 1) * (a + b) = a + (b + a + b) := by
      rw [Ring‚ÇÉ.right_distrib, one_mul]
      repeat rw [add_assoc‚ÇÉ]
    apply add_right_cancel‚ÇÉ
    apply add_left_cancel‚ÇÉ
    rw [‚Üê h‚ÇÅ, h‚ÇÇ]
   }

instance : Ring‚ÇÉ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := add_assoc
  zero := 0
  zero_add := by simp
  add_zero := by simp
  neg := (- ¬∑)
  neg_add := by simp
  mul := (¬∑ * ¬∑)
  mul_assoc‚ÇÉ := mul_assoc
  one := 1
  one_mul := by simp
  mul_one := by simp
  zero_mul := by simp
  mul_zero := by simp
  left_distrib := Int.mul_add
  right_distrib := Int.add_mul

class LE‚ÇÅ (Œ± : Type) where
  /-- The Less-or-Equal relation. -/
  le : Œ± ‚Üí Œ± ‚Üí Prop

@[inherit_doc] infix:50 " ‚â§‚ÇÅ " => LE‚ÇÅ.le

class Preorder‚ÇÅ (Œ± : Type) extends LE‚ÇÅ Œ± where
  le_refl‚ÇÅ : ‚àÄ a : Œ±, a ‚â§‚ÇÅ a
  le_trans‚ÇÅ {a b c : Œ±} : a ‚â§‚ÇÅ b ‚Üí b ‚â§‚ÇÅ c ‚Üí a ‚â§‚ÇÅ c

class PartialOrder‚ÇÅ (Œ± : Type) extends Preorder‚ÇÅ Œ± where
  le_antisymm‚ÇÅ {a b : Œ±} : a ‚â§‚ÇÅ b ‚Üí b ‚â§‚ÇÅ a ‚Üí a = b

class OrderedCommMonoid‚ÇÅ (Œ± : Type) extends CommMonoid‚ÇÉ Œ±, PartialOrder‚ÇÅ Œ± where
  mul_le_mul_left‚ÇÅ {a b : Œ±} : ‚àÄ c : Œ±, a ‚â§‚ÇÅ b ‚Üí c * a ‚â§‚ÇÅ c * b

instance : OrderedCommMonoid‚ÇÅ ‚Ñï where
  mul_assoc‚ÇÉ := Nat.mul_assoc
  one_mul := Nat.one_mul
  mul_one := Nat.mul_one
  mul_comm := Nat.mul_comm
  le := (¬∑ ‚â§ ¬∑)
  le_refl‚ÇÅ := Nat.le_refl
  le_trans‚ÇÅ := Nat.le_trans
  le_antisymm‚ÇÅ := Nat.le_antisymm
  mul_le_mul_left‚ÇÅ := Nat.mul_le_mul_left

class SMul‚ÇÉ (Œ± : Type) (Œ≤ : Type) where
  /-- Scalar multiplication -/
  smul : Œ± ‚Üí Œ≤ ‚Üí Œ≤

infixr:73 " ‚Ä¢ " => SMul‚ÇÉ.smul

-- each class appearing in the extends clause should mention every type appearing in the parameters of the class
-- otherwise, specify them as a parameter in square brackets
class Module‚ÇÅ (R : Type) [Ring‚ÇÉ R] (M : Type) [AddCommGroup‚ÇÉ M] extends SMul‚ÇÉ R M where
  zero_smul : ‚àÄ m : M, (0 : R) ‚Ä¢ m = 0
  one_smul : ‚àÄ m : M, (1 : R) ‚Ä¢ m = m
  mul_smul : ‚àÄ (a b : R) (m : M), (a * b) ‚Ä¢ m = a ‚Ä¢ b ‚Ä¢ m
  add_smul : ‚àÄ (a b : R) (m : M), (a + b) ‚Ä¢ m = a ‚Ä¢ m + b ‚Ä¢ m
  smul_add : ‚àÄ (a : R) (m n : M), a ‚Ä¢ (m + n) = a ‚Ä¢ m + a ‚Ä¢ n

-- observe that we have added data here as smul, and yet selfModule is not concrete
--   (recall in comparison where we added data elsewhere,
--   in SMul, in LE, One, Dia; all at the top of their hierarchies. This will come to bite us later)
instance selfModule (R : Type) [Ring‚ÇÉ R] : Module‚ÇÅ R R where
  smul := fun r s ‚Ü¶ r*s
  zero_smul := zero_mul
  one_smul := one_mul
  mul_smul := mul_assoc‚ÇÉ
  add_smul := Ring‚ÇÉ.right_distrib
  smul_add := Ring‚ÇÉ.left_distrib

def nsmul‚ÇÅ [Zero M] [Add M] : ‚Ñï ‚Üí M ‚Üí M
  | 0, _ => 0
  | n + 1, a => a + nsmul‚ÇÅ n a

def zsmul‚ÇÅ {M : Type*} [Zero M] [Add M] [Neg M] : ‚Ñ§ ‚Üí M ‚Üí M
  | Int.ofNat n, a => nsmul‚ÇÅ n a
  | Int.negSucc n, a => -nsmul‚ÇÅ n.succ a

-- observe that we have added data here as smul, and yet abGrpModule is not concrete
--   (recall in comparison where we added data elsewhere,
--   in SMul, in LE, One, Dia; all at the top of their hierarchies. This will come to bite us later)
instance abGrpModule (A : Type) [AddCommGroup‚ÇÉ A] : Module‚ÇÅ ‚Ñ§ A where
  smul := zsmul‚ÇÅ
  zero_smul := sorry
  one_smul := sorry
  mul_smul := sorry
  add_smul := sorry
  smul_add := sorry

-- demonstration that the synthesized instance is bad
-- the robust way to fix the diamond problem is to ensure that going from rich structure to poor structure
-- we always forget data, not define data. We call this "forgetful inheritance" (https://inria.hal.science/hal-02463336)
-- see: library_note "forgetful inheritance" in https://github.com/leanprover-community/mathlib4/Mathlib/Algebra/Group/Defs.lean
#synth Module‚ÇÅ ‚Ñ§ ‚Ñ§ -- abGrpModule ‚Ñ§
-- and not selfModule ‚Ñ§
-- these two concrete instances are not definitionally equal, though they actually are

-- to fix thes particular case, we consider defining a default notion of nsmul way higher in the hierarchy
-- Here, we can modify the definition of AddMonoid‚ÇÉ to include a nsmul data field and some Prop-valued fields ensuring this operation is provably the one we constructed above.
-- This is the more natural place to establish the relationship between monoids and ‚Ñï (analogous to groups and ‚Ñ§)
class AddMonoid‚ÇÑ (M : Type) extends AddSemigroup‚ÇÉ M, AddZeroClass M where
  /-- Multiplication by a natural number. -/
  nsmul : ‚Ñï ‚Üí M ‚Üí M := nsmul‚ÇÅ
  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/
  nsmul_zero : ‚àÄ x, nsmul 0 x = 0 := by intros; rfl
  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/
  nsmul_succ : ‚àÄ (n : ‚Ñï) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl

instance mySMul {M : Type} [AddMonoid‚ÇÑ M] : SMul ‚Ñï M := ‚ü®AddMonoid‚ÇÑ.nsmul‚ü©

-- we demonstrate how this works with the product monoid
-- and observe that we did not need to define the fields that have default values in AddMonoid‚ÇÑ
instance (M N : Type) [AddMonoid‚ÇÑ M] [AddMonoid‚ÇÑ N] : AddMonoid‚ÇÑ (M √ó N) where
  add := fun p q ‚Ü¶ (p.1 + q.1, p.2 + q.2)
  add_assoc‚ÇÉ := fun a b c ‚Ü¶ by ext <;> apply add_assoc‚ÇÉ
  zero := (0, 0)
  zero_add := fun a ‚Ü¶ by ext <;> apply zero_add
  add_zero := fun a ‚Ü¶ by ext <;> apply add_zero

-- we now show that ‚Ñ§ is a monoid
-- we see we have replaced the definition of nsmul with the one we want
-- but of course, while it has different computational and definitional properties, the mathematical relationship is the same
instance : AddMonoid‚ÇÑ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := Int.add_assoc
  zero := 0
  zero_add := Int.zero_add
  add_zero := Int.add_zero
  nsmul := fun n m ‚Ü¶ (n : ‚Ñ§) * m
  nsmul_zero := Int.zero_mul
  nsmul_succ := fun n m ‚Ü¶ show (n + 1 : ‚Ñ§) * m = m + n * m
    by rw [Int.add_mul, Int.add_comm, Int.one_mul]

-- we now show that it is possible to provide a scalar multiplication for ‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñ§
example (n : ‚Ñï) (m : ‚Ñ§) : SMul.smul (self := mySMul) n m = n * m := rfl

-- This story then continues with incorporating a zsmul field into the definition of groups and similar tricks.

class LT‚ÇÅ (Œ± : Type) where
  /-- The Less-Than relation. -/
  lt : Œ± ‚Üí Œ± ‚Üí Prop

@[inherit_doc] infix:50 " <‚ÇÅ " => LT‚ÇÅ.lt

class Preorder‚ÇÇ (Œ± : Type) extends LE‚ÇÅ Œ±, LT‚ÇÅ Œ± where
  le_refl‚ÇÅ : ‚àÄ a : Œ±, a ‚â§‚ÇÅ a
  le_trans‚ÇÅ {a b c : Œ±} : a ‚â§‚ÇÅ b ‚Üí b ‚â§‚ÇÅ c ‚Üí a ‚â§‚ÇÅ c
  lt := fun a b ‚Ü¶ a ‚â§‚ÇÅ b ‚àß ¬¨b ‚â§‚ÇÅ a
  lt_iff_le_not_le : ‚àÄ a b : Œ±, a <‚ÇÅ b ‚Üî a ‚â§‚ÇÅ b ‚àß ¬¨ b ‚â§‚ÇÅ a := by intros; rfl
